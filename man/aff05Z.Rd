% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/affinity_05Z.R
\name{aff05Z}
\alias{aff05Z}
\title{Affinity by Adaptive Kernel by Zelnik-Manor and Perona (2005)}
\usage{
aff05Z(X, nbdk = 5, ...)
}
\arguments{
\item{X}{an \eqn{(m\times p)} matrix of row-stacked observations of S3 \code{dist} object of \eqn{m} observations.}

\item{nbdk}{neighborhood size to define data-driven bandwidth parameter (default: 5).}

\item{...}{extra parameters including \describe{
\item{alpha}{normalization constant; one of \code{c(0, 0.5, 1)} (default: \code{0}).}
\item{zero.diag}{a logical; set the diagonal entries as zeros (default: \code{FALSE}).}
}}
}
\value{
an \eqn{(m\times m)} affinity matrix of \code{"affinity"} class.
}
\description{
\insertCite{zelnik-manor_self-tuning_2005;textual}{dglearn} proposed to define data-driven bandwidth parameters 
using the nearest-neighbor distances. Let \eqn{\sigma_i} be the distance from a point \eqn{x_i} to its \code{nnbd}-th 
nearest neighbor. Then the affinity matrix is defined as
\deqn{A_{ij} = \exp(-\|x_i - x_j\|^2 / \sigma_i \sigma_j)} 
so that it reflects density of the data.
}
\examples{
\donttest{
## load 'iris' data
data("iris")

## extract the numerical part
iris_mat = as.matrix(iris[,1:4])

## compute affinity using different neighbor sizes
aff1 = aff05Z(iris_mat, nbdk=5)
aff2 = aff05Z(iris_mat, nbdk=10)
aff3 = aff05Z(iris_mat, nbdk=20)

## visualize
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
image(aff1, xaxt="n", yaxt="n", xlab="", ylab="", main='nbdk=5')
image(aff2, xaxt="n", yaxt="n", xlab="", ylab="", main='nbdk=10')
image(aff3, xaxt="n", yaxt="n", xlab="", ylab="", main='nbdk=20')
par(opar)
}

}
\references{
\insertAllCited{}
}
\concept{affinity}
